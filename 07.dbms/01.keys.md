
## **1. What are Keys in DBMS?**

In a **Database Management System (DBMS)**, a **key** is a special field (or a combination of fields) that helps:

* **Uniquely identify** a record in a table.
* **Establish relationships** between tables.
* **Enforce integrity** (no duplicate or invalid records).

In relational databases like **MySQL** or **PostgreSQL**, keys are fundamental for normalization and relationships.
In **MongoDB**, which is document-oriented, the concepts are implemented differently but serve the same logical purpose.

---

## **2. Types of Keys in DBMS**

Let’s go one by one — from the most basic to the most advanced types.

---

### **2.1 Super Key**

A **Super Key** is any attribute (or group of attributes) that **uniquely identifies** a record in a table.

#### Example (Relational DBMS)

| RollNo | Name   | Email                                                 | Phone      |
| ------ | ------ | ----------------------------------------------------- | ---------- |
| 1      | Arjun  | [arjun@codinggita.com](mailto:arjun@codinggita.com)   | 9991112222 |
| 2      | Yashvi | [yashvi@codinggita.com](mailto:yashvi@codinggita.com) | 9993334444 |

Possible **Super Keys**:

* `{RollNo}`
* `{Email}`
* `{Phone}`
* `{RollNo, Email}`
* `{RollNo, Phone}`

All these can uniquely identify a student.

#### **MongoDB Equivalent**

In MongoDB, any field that **uniquely identifies** a document is a **super key**.
By default, every document has a **unique `_id` field** — so `_id` is a super key automatically.

Example document in `students` collection:

```json
{
  "_id": ObjectId("672e41f8e1b8b4c3c4a7d1c2"),
  "rollNo": 1,
  "name": "Arjun",
  "email": "arjun@codinggita.com",
  "phone": "9991112222"
}
```

Here:

* `_id`
* `email`
* `phone`
  Each can act as a **super key** if you enforce uniqueness.

---

### **2.2 Candidate Key**

A **Candidate Key** is a **minimal super key** — meaning it uniquely identifies a record but doesn’t have any unnecessary attributes.

From the earlier example:

* `{RollNo}`, `{Email}`, and `{Phone}` are **candidate keys** (since they’re minimal and unique).
* `{RollNo, Email}` is not — because both RollNo and Email individually can identify a record.

#### **MongoDB Equivalent**

MongoDB doesn’t formally define “candidate keys”, but:

* `_id` is **always** a candidate key.
* You can **create unique indexes** on fields like `email` or `phone` to make them behave as candidate keys.

```js
db.students.createIndex({ email: 1 }, { unique: true })
db.students.createIndex({ phone: 1 }, { unique: true })
```

---

### **2.3 Primary Key**

A **Primary Key** is the **main key** chosen among candidate keys to **uniquely identify** a record.
Each table can have **only one primary key**.

#### Example (RDBMS)

```sql
CREATE TABLE Students (
  RollNo INT PRIMARY KEY,
  Name VARCHAR(50),
  Email VARCHAR(100) UNIQUE,
  Phone VARCHAR(15) UNIQUE
);
```

Here `RollNo` is the **primary key**.

#### **MongoDB Equivalent**

In MongoDB:

* Every document automatically gets an **`_id` field** (unique per collection).
* `_id` acts as the **primary key**.

Example:

```json
{
  "_id": ObjectId("672e41f8e1b8b4c3c4a7d1c2"),
  "rollNo": 1,
  "name": "Arjun"
}
```

MongoDB automatically indexes `_id`, and you cannot have two documents with the same `_id`.

---

### **2.4 Alternate Key**

An **Alternate Key** is any **candidate key** that is **not chosen** as the primary key.

#### Example (RDBMS)

If:

* Candidate keys = `{RollNo}`, `{Email}`, `{Phone}`
* Primary key = `RollNo`

Then:

* `{Email}` and `{Phone}` become **alternate keys**.

#### **MongoDB Equivalent**

In MongoDB, any other **unique index** (apart from `_id`) acts as an **alternate key**.

```js
db.students.createIndex({ email: 1 }, { unique: true })
```

Here `email` is an **alternate key** because `_id` is already the primary key.

---

### **2.5 Composite Key (or Compound Key)**

A **Composite Key** consists of **two or more attributes** that together uniquely identify a record.

#### Example (RDBMS)

| CourseID | StudentID | Marks |
| -------- | --------- | ----- |
| CS101    | 1         | 90    |
| CS101    | 2         | 85    |
| CS102    | 1         | 80    |

Here, neither `CourseID` nor `StudentID` alone can uniquely identify a row.
The combination `(CourseID, StudentID)` is the **composite key**.

```sql
PRIMARY KEY (CourseID, StudentID)
```

#### **MongoDB Equivalent**

MongoDB doesn’t have composite primary keys, but you can achieve similar behavior by:

* Creating a **compound unique index**.

```js
db.results.createIndex(
  { courseId: 1, studentId: 1 },
  { unique: true }
)
```

This ensures no two documents have the same combination of `courseId` and `studentId`.

---

### **2.6 Foreign Key**

A **Foreign Key** is an attribute that creates a **relationship between two tables** — it refers to the **primary key of another table**.

#### Example (RDBMS)

```sql
CREATE TABLE Students (
  RollNo INT PRIMARY KEY,
  Name VARCHAR(50)
);

CREATE TABLE Results (
  ResultID INT PRIMARY KEY,
  RollNo INT,
  Marks INT,
  FOREIGN KEY (RollNo) REFERENCES Students(RollNo)
);
```

This ensures `Results.RollNo` must exist in the `Students` table.

#### **MongoDB Equivalent**

MongoDB is **non-relational**, so it doesn’t have foreign keys, but you can **simulate relationships** using:

1. **Manual referencing**

   ```json
   // students collection
   { "_id": 1, "name": "Arjun" }

   // results collection
   { "_id": 101, "studentId": 1, "marks": 90 }
   ```
2. **DBRef (rarely used)**

   ```json
   { "student": { "$ref": "students", "$id": 1 } }
   ```
3. **Embedded documents (preferred)**

   ```json
   {
     "_id": 101,
     "student": { "id": 1, "name": "Arjun" },
     "marks": 90
   }
   ```

---

### **2.7 Unique Key**

A **Unique Key** ensures all values in a column are **different**, similar to a primary key, but it can accept **NULL** values (unlike primary key).

#### Example (RDBMS)

```sql
CREATE TABLE Employees (
  EmpID INT PRIMARY KEY,
  Email VARCHAR(100) UNIQUE
);
```

Here both `EmpID` and `Email` must be unique.

#### **MongoDB Equivalent**

You can enforce uniqueness using:

```js
db.employees.createIndex({ email: 1 }, { unique: true })
```

This ensures no two employees have the same email.

---

### **2.8 Secondary Key (or Non-unique Key)**

A **Secondary Key** is used **only for searching or indexing**, not for unique identification.

#### Example (RDBMS)

If you frequently search students by name:

```sql
CREATE INDEX idx_name ON Students(Name);
```

`Name` is a **secondary key**.

#### **MongoDB Equivalent**

MongoDB supports secondary indexes:

```js
db.students.createIndex({ name: 1 })
```

Now queries like:

```js
db.students.find({ name: "Arjun" })
```

become faster.

---

### **2.9 Surrogate Key**

A **Surrogate Key** is an **artificial key** created by the system (not derived from business data) — usually an auto-increment or generated ID.

#### Example (RDBMS)

```sql
CREATE TABLE Students (
  ID INT AUTO_INCREMENT PRIMARY KEY,
  RollNo VARCHAR(10),
  Name VARCHAR(50)
);
```

`ID` is a **surrogate key**.

#### **MongoDB Equivalent**

MongoDB’s **`_id` field** is a perfect example of a **surrogate key**, automatically generated as an **ObjectId**.

---

## **3. Summary Table**

| **Key Type**  | **Description**                             | **Example (RDBMS)**   | **MongoDB Equivalent**        |
| ------------- | ------------------------------------------- | --------------------- | ----------------------------- |
| Super Key     | Any attribute(s) uniquely identifying a row | RollNo, Email         | `_id`, `email`                |
| Candidate Key | Minimal super key                           | RollNo                | `_id`, unique index           |
| Primary Key   | Chosen main identifier                      | RollNo                | `_id`                         |
| Alternate Key | Candidate key not used as primary           | Email                 | Unique index on email         |
| Composite Key | Combination of fields                       | (CourseID, StudentID) | Compound unique index         |
| Foreign Key   | References another table                    | StudentID → Students  | Manual reference or embedding |
| Unique Key    | Ensures unique values                       | Email UNIQUE          | Unique index                  |
| Secondary Key | Used for searching                          | Index on Name         | Index on name                 |
| Surrogate Key | System-generated identifier                 | Auto ID               | `_id` (ObjectId)              |

---

## **4. Real-World MongoDB Example (CodingGita Students Database)**

```js
db.students.insertMany([
  {
    _id: ObjectId(),
    rollNo: 101,
    name: "Arjun",
    email: "arjun@codinggita.com",
    phone: "9991112222"
  },
  {
    _id: ObjectId(),
    rollNo: 102,
    name: "Yashvi",
    email: "yashvi@codinggita.com",
    phone: "9993334444"
  }
]);

// Primary key
// _id is automatically unique

// Alternate key
db.students.createIndex({ email: 1 }, { unique: true });

// Secondary key
db.students.createIndex({ name: 1 });

// Composite key (course + student)
db.enrollments.createIndex({ courseId: 1, studentId: 1 }, { unique: true });
```

---

## **5. Conclusion**

* **Relational DBMS** uses keys to maintain **data integrity** and **relationships**.
* **MongoDB** achieves similar results using:

  * `_id` (as a **primary/surrogate key**)
  * **Unique indexes** (as **alternate/unique keys**)
  * **Compound indexes** (as **composite keys**)
  * **References or embedding** (as **foreign keys**)

MongoDB is schema-less, but **data modeling best practices** encourage thoughtful key usage to maintain logical relationships and performance efficiency.

---
