# **4 — Third Normal Form (3NF): Removing Transitive Dependencies**

---

## **1. The Story So Far**

So far, we’ve made great progress:

* **1NF:** Made data atomic (no multi-valued fields)
* **2NF:** Removed partial dependencies by splitting Investors, Funds, and Holdings

Now our database looks clean, but not *perfect* yet.
There’s one more kind of dependency that can still cause inconsistency — the **transitive dependency**.

---

## **2. Understanding 3NF in Plain English**

Let’s break it down without jargon first.

Imagine you’re running a mutual fund management system.
You already have three well-structured tables:

* **Investors** — Who invests
* **Funds** — What mutual funds exist
* **Holdings** — Which investor holds which fund

But in your **Funds** table, you also decide to store another column — **RiskLevel**, because each category (like *Large Cap* or *Small Cap*) is associated with a typical risk level.

| FundID | FundName            | Category  | RiskLevel |
| ------ | ------------------- | --------- | --------- |
| F001   | Axis Bluechip Fund  | Large Cap | Medium    |
| F002   | ICICI Balanced Fund | Hybrid    | Medium    |
| F003   | HDFC Small Cap Fund | Small Cap | High      |

Seems fine, right?

But notice something subtle:

* The `RiskLevel` isn’t directly tied to the fund itself.
* Instead, it depends on the **Category** — every “Large Cap” fund has “Medium” risk, every “Small Cap” has “High” risk.

That’s called a **transitive dependency**:

```
FundID → Category → RiskLevel
```

The problem?
If tomorrow you decide “Large Cap” should be “Low” risk instead of “Medium,” you’ll have to update multiple rows across the Funds table — and that’s *exactly the kind of redundancy normalization avoids*.

---

## **3. The Real Meaning of 3NF**

Here’s the official but simplified definition:

> **A table is in Third Normal Form (3NF)** if:
>
> 1. It is already in 2NF, and
> 2. There are **no transitive dependencies** — i.e., non-key columns do not depend on other non-key columns.

In simple words:

> Every non-key field must depend *only* on the primary key, not on another non-key field.

---

## **4. Identifying the Problem in Our Mutual Fund Table**

Let’s restate our 2NF version of the `Funds` table:

| FundID | FundName            | Category  | NAV    | RiskLevel |
| ------ | ------------------- | --------- | ------ | --------- |
| F001   | Axis Bluechip Fund  | Large Cap | 45.30  | Medium    |
| F002   | ICICI Balanced Fund | Hybrid    | 120.50 | Medium    |
| F003   | HDFC Small Cap Fund | Small Cap | 25.80  | High      |

Here’s what’s happening behind the scenes:

| Dependency Type | Functional Dependency            | Explanation                          |
| --------------- | -------------------------------- | ------------------------------------ |
| Direct          | FundID → FundName, Category, NAV | Each fund determines these directly  |
| **Transitive**  | Category → RiskLevel             | Risk depends indirectly via category |

Since `RiskLevel` depends on `Category`, not directly on `FundID`, the table violates 3NF.

---

## **5. The Fix — Break the Transitive Dependency**

To remove the transitive dependency, we create a new table for **FundCategories** (or **CategoryMaster**) that maps each fund category to its risk level.

### **Decomposition:**

#### **A. FundCategories Table**

| Category  | RiskLevel |
| --------- | --------- |
| Large Cap | Medium    |
| Hybrid    | Medium    |
| Small Cap | High      |

#### **B. Funds Table (Now 3NF)**

| FundID | FundName            | Category  | NAV    |
| ------ | ------------------- | --------- | ------ |
| F001   | Axis Bluechip Fund  | Large Cap | 45.30  |
| F002   | ICICI Balanced Fund | Hybrid    | 120.50 |
| F003   | HDFC Small Cap Fund | Small Cap | 25.80  |

Now:

* `FundID → Category`
* `Category → RiskLevel`
  Each dependency sits in its correct table.
  No redundancy, no multiple updates, no inconsistency.

---

## **6. SQL Representation (3NF Design)**

```sql
-- Fund Categories (master data)
CREATE TABLE FundCategories (
  Category VARCHAR(50) PRIMARY KEY,
  RiskLevel VARCHAR(20)
);

-- Funds
CREATE TABLE Funds (
  FundID VARCHAR(10) PRIMARY KEY,
  FundName VARCHAR(200),
  Category VARCHAR(50),
  NAV DECIMAL(10,2),
  FOREIGN KEY (Category) REFERENCES FundCategories(Category)
);
```

**Example Insertions:**

```sql
INSERT INTO FundCategories VALUES
('Large Cap', 'Medium'),
('Hybrid', 'Medium'),
('Small Cap', 'High');

INSERT INTO Funds VALUES
('F001', 'Axis Bluechip Fund', 'Large Cap', 45.30),
('F002', 'ICICI Balanced Fund', 'Hybrid', 120.50),
('F003', 'HDFC Small Cap Fund', 'Small Cap', 25.80);
```

---

## **7. How This Solves Real Problems**

| Problem                            | Before (2NF)                   | After (3NF)                         |
| ---------------------------------- | ------------------------------ | ----------------------------------- |
| Updating risk level for a category | Had to update multiple rows    | Update once in `FundCategories`     |
| Inconsistent risk labels           | Possible if one row was missed | Impossible (single source of truth) |
| Adding new category                | Mixed with fund data           | Cleanly managed in separate table   |

---

## **8. Real-World Analogy**

Think of your **Category** as a “Type” of fund — Large Cap, Hybrid, Small Cap — and **RiskLevel** as a property of that type.

You wouldn’t want to repeat “Large Cap → Medium risk” for 50 different funds.
Instead, you keep that fact in one safe place (the `FundCategories` table) — just like keeping all risk definitions in a master reference file in your office.

---

## **9. Recap Table**

| Term                  | Meaning                                            | Mutual Fund Example                  |
| --------------------- | -------------------------------------------------- | ------------------------------------ |
| Transitive Dependency | A non-key column depends on another non-key column | FundID → Category → RiskLevel        |
| 3NF Rule              | No transitive dependencies                         | Move `RiskLevel` to `FundCategories` |
| Benefit               | No duplicate risk info, consistent data            | Update risk once per category        |

---

## **10. What Our Database Looks Like Now**

We’ve gradually built a clean, logical schema:

**Investors Table**
→ Stores investor details.

**Funds Table**
→ Stores fund metadata.

**FundCategories Table**
→ Stores category–risk mapping.

**Holdings Table**
→ Stores who invested, how much, and when.

All relationships are clear, every table has a single purpose, and every dependency flows directly from key to attribute.

---

## **11. Summary of Progress So Far**

| Normal Form | Problem Solved                          | Fix Applied                                  | Result                     |
| ----------- | --------------------------------------- | -------------------------------------------- | -------------------------- |
| **1NF**     | Repeating groups / multi-valued columns | Make values atomic                           | One fact per cell          |
| **2NF**     | Partial dependencies                    | Split into Investors, Funds, Holdings        | One theme per table        |
| **3NF**     | Transitive dependencies                 | Separate derived info (Category → RiskLevel) | No redundant indirect data |

---
